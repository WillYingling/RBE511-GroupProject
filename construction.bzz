# the radius of the robot
ROBOT_RADIUS = 0.0704

# maximum wheel speed
MAX_SPEED = 10.0

# the location of the wall to build
WALL_LOCATION = 0.0

# the length of the wall to build
WALL_LENGTH = 4.0

# the length of the blocks used for construction (assumes square blocks with length = width)
BLOCK_LENGTH = 0.3

# the different states of the agent - it is either searching for blocks, attempting to push them,
# or escaping a trap
SEARCH = 0
PUSH   = 1
ESCAPE = 2

# threshold used to denote contact with object
CONTACT_THRESH = 0.6

# threshold used to denote a robot is stuck
STUCK_THRESH = 0.001

# gains used for proportional controller
Kp_dist    = 100
Kp_heading = 5

function init() {
    reset()
}

function step() {
    if (state == SEARCH) {
        process_search_state()
    }

    if (state == PUSH) {
        process_push_state()
    }

    if (state == ESCAPE) {
        process_escape_state()
    }

    max_prox = math.max(proximity[0].value, math.max(proximity[1].value, proximity[7].value))
    if (state == SEARCH) {
        debug.print("SEARCH ", max_prox)
    } else if (state == PUSH) {
        debug.print("PUSH ", max_prox)
    } else {
        debug.print("ESCAPE ", max_prox)
    }

    # record pose
    last_x = pose.position.x
    last_y = pose.position.y
    last_h = pose.orientation.yaw
}

function reset() {
    # initialize stigmergy representing the state of each desired block placement
    # the state is either "unassigned", "placed", or "<y-coordinate of assigned agent>"
    blocks = stigmergy.create(1)

    # the number of blocks needed to create the wall
    num_blocks = math.floor(WALL_LENGTH / BLOCK_LENGTH)

    # the length of the wall actually covered by blocks
    covered_length = num_blocks * BLOCK_LENGTH

    # the length of the gap between blocks
    gap_length = (WALL_LENGTH - covered_length) / (num_blocks + 1)

    # compute desired block locations and mark them as unassigned
    block_locations = {}
    i = 0
    while (i < num_blocks) {
        block_locations[i] = -0.5 * WALL_LENGTH + gap_length + 0.5 * BLOCK_LENGTH + i * (BLOCK_LENGTH + gap_length)
        blocks.put(i, "unassigned")
        i = i + 1
    }

    # index of block to drive towards (initially unassigned)
    goal_block = -1

    # start by searching for obstacles
    state = SEARCH

    # drive forward
    set_wheels(MAX_SPEED, MAX_SPEED)

    # record pose
    last_x = pose.position.x
    last_y = pose.position.y
    last_h = pose.orientation.yaw

    # conflicts will be resolved by favoring closer agents
    blocks.onconflict(function(k, l, r) {
        # does not matter if they are the same
        # choose report for lower id just to resolve conflict
        if (l.data == r.data) {
            if (l.robot < r.robot) {
                return l
            }
            return r
        }

        log("robot: ", id, " - conflict encountered for block location ", block_locations[k], " - robot=", l.robot, " with y=", l.data, " at t=", l.timestamp, " vs robot=", r.robot, " with y=", r.data, " at t=", r.timestamp)

        # priority goes to marking a block as placed
        if (l.data == "placed") {
            return l
        }
        if (r.data == "placed") {
            return r
        }

        # priority goes to marking a block as assigned
        if (l.data == "unassigned") {
            return r
        }
        if (r.data == "unassigned") {
            return l
        }

        # priority goes to closer y-coordinate
        y_local = string.tofloat(l.data)
        if (isnil(y_local)) {
            return r
        }

        y_remote = string.tofloat(r.data)
        if (isnil(y_remote)) {
            return l
        }

        d_local  = math.abs(k - y_local)
        d_remote = math.abs(k - y_remote)

        if (d_local < d_remote) {
            return l
        }

        return r
    })

    # loser get unassigned
    blocks.onconflictlost(function(k, l) {
        if (k == goal_block) {
            log("robot: ", id, " - conflict lost for block location ", block_locations[k], " with y=", l.data)
            goal_block = -1
        }
    })
}

function destroy() {
}

function process_search_state() {
    # check if we are in contact with an object
    if (get_contact()) {
        # transition to push state
        state = PUSH
        log("robot: ", id, " - contact made - transition SEARCH to PUSH")
    } else {
         # check if we are stuck
        traveled_distance = math.sqrt((pose.position.x - last_x) ^ 2 + (pose.position.y - last_y) ^ 2)
        traveled_heading  = (last_h - pose.orientation.yaw + math.pi) % (2 * math.pi) - math.pi
        if ((math.abs(traveled_heading) < 1.0 * math.pi / 180) and (traveled_distance < STUCK_THRESH)) {
            # transition to escape state
            state = ESCAPE
            log("robot: ", id, " - stuck - transition SEARCH to ESCAPE")
        } else {
            # drive forward
            set_wheels(MAX_SPEED, MAX_SPEED)
        }
    }
}

function process_push_state() {
    # check if we are in contact with an object
    if (not get_contact()) {
        # transition to search state
        state = SEARCH
        log("robot: ", id, " - contact lost - transition PUSH to SEARCH ")
    } else {
        # make sure we have a task
        new = false
        if (goal_block < 0) {
            goal_block = get_goal_block()
            new        = true
        }

        if (goal_block < 0) {
            state = ESCAPE
            log("robot: ", id, " - no accomplishable tasks - transition PUSH to ESCAPE")
        } else {
            blocks.put(goal_block, string.tostring(pose.position.y))
            log("robot: ", id, " - assigned to task ", goal_block, " at y=", block_locations[goal_block])

            # check if we are done with our task
            goal_distance = get_goal_distance()
            if (goal_distance < 0.01) {
                # mark task as complete
                blocks.put(goal_block, "placed")
                goal_block = -1

                # transition to escape state
                state = ESCAPE
                log("robot: ", id, " - task complete - transition PUSH to ESCAPE")
            } else {
                # check to make sure we are not moving a placed block
                if ((math.abs(WALL_LOCATION - pose.position.x) < 0.5 * BLOCK_LENGTH + ROBOT_RADIUS) and (get_closest_block() != goal_block)) {
                    # mark task as incomplete
                    blocks.put(goal_block, "unassigned")
                    goal_block = -1

                    # transition to escape state
                    state = ESCAPE
                    log("robot: ", id, " - avoiding moving placed block - transition PUSH to ESCAPE")
                } else {
                    # check if we are stuck
                    traveled_distance = math.sqrt((pose.position.x - last_x) ^ 2 + (pose.position.y - last_y) ^ 2)
                    if ((not new) and (traveled_distance < STUCK_THRESH)) {
                        # mark task as incomplete
                        blocks.put(goal_block, "unassigned")
                        goal_block = -1

                        # transition to escape state
                        state = ESCAPE
                        log("robot: ", id, " - stuck - transition PUSH to ESCAPE")
                    } else {
                        # start with forward motion
                        base_speed = math.min(MAX_SPEED, Kp_dist * goal_distance)

                        # adjust motion to account for heading error
                        goal_heading = get_goal_heading()
                        yaw_error    = (goal_heading - pose.orientation.yaw + math.pi) % (2 * math.pi) - math.pi
                        w            = Kp_heading * yaw_error

                        # drive
                        set_wheels(base_speed - w, base_speed + w)
                    }
                }
            }
        }
    }
}

function process_escape_state() {
    if (get_contact()) {
        # rotate
        set_wheels(-MAX_SPEED, MAX_SPEED)
    } else {
        state = SEARCH
        log("robot: ", id, " - escaped - transition ESCAPE to SEARCH")
    }
}

function get_contact() {
    return proximity[0].value >= CONTACT_THRESH or proximity[1].value >= CONTACT_THRESH or proximity[7].value >= CONTACT_THRESH
}

function get_goal_block() {
    d_min = 1000.0
    k_min = -1

    blocks.foreach(function(key, value, robot) {
        # check if block is unassigned
        if (value == "unassigned") {
            # determine if desired block location is above or below the robot
            # as well as if it is to the right or left of the robot
            heading = pose.orientation.yaw
            dx      = WALL_LOCATION - pose.position.x
            dy      = block_locations[key] - pose.position.y
            above   = (dy > 0.0)
            right   = (dx > 0.0)
            east    = ((-0.5 * math.pi < heading) and (heading < 0.5 * math.pi))
            north   = (heading > 0.0)

            if ((above == north) and (right == east)) {
                # check if new closest was found
                d = math.abs(dy)
                if (d < d_min) {
                    k_min = key
                    d_min = d
                }
            }
        }
    })

    return k_min
}

function get_closest_block() {
    d_min = 1000.0
    k_min = -1

    blocks.foreach(function(key, value, robot) {
        # check if new closest was found
        d = math.abs(dy)
        if (d < d_min) {
            k_min = key
            d_min = d
        }
    })

    return k_min
}

function get_goal_distance() {
    distance = 0

    if (goal_block >= 0) {
        sign = 1
        if (pose.position.x < WALL_LOCATION) {
            sign = -1
        }

        goal_x   = WALL_LOCATION + sign * (0.5 * BLOCK_LENGTH + ROBOT_RADIUS)
        goal_y   = block_locations[goal_block]
        distance = math.sqrt((goal_y - pose.position.y) ^ 2 + (goal_x - pose.position.x) ^ 2)
    }

    return distance
}

function get_goal_heading() {
    heading = 0

    if (goal_block >= 0) {
        sign = 1
        if (pose.position.x < WALL_LOCATION) {
            sign = -1
        }

        goal_x  = WALL_LOCATION + sign * (0.5 * BLOCK_LENGTH + ROBOT_RADIUS)
        goal_y  = block_locations[goal_block]
        heading = math.atan(goal_y - pose.position.y, goal_x - pose.position.x)
    }

    return heading
}