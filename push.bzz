function process_push_state() {
    # check if we are in contact with an object
    if (not get_contact()) {
        # transition to search state
        state = SEARCH
        log("robot: ", id, " - contact lost - transition PUSH to SEARCH ")
    } else {
        # make sure we have a task
        new = 0
        if (goal_block < 0) {
            goal_block = get_goal_block()
            new        = 1
        }

        if (goal_block < 0) {
            change_state(ESCAPE)
            log("robot: ", id, " - no accomplishable tasks - transition PUSH to ESCAPE")
        } else {
            blocks.put(goal_block, string.tostring(pose.position.y))
            log("robot: ", id, " - assigned to task ", goal_block, " at y=", block_locations[goal_block])

            # check if we are done with our task
            goal_distance = get_goal_distance()
            if (goal_distance < 0.01) {
                # mark task as complete
                blocks.put(goal_block, "placed")
                goal_block = -1

                # transition to escape state
                change_state(ESCAPE)
                log("robot: ", id, " - task complete - transition PUSH to ESCAPE")
            } else {
                # check if we are stuck
                traveled_distance = math.sqrt((pose.position.x - last_x) ^ 2 + (pose.position.y - last_y) ^ 2)
                if ((not new) and (traveled_distance < STUCK_THRES)) {
                    # mark task as incomplete
                    blocks.put(goal_block, "unassigned")
                    goal_block = -1

                    # transition to escape state
                    change_state(ESCAPE)
                    log("robot: ", id, " - stuck - transition PUSH to ESCAPE")
                } else {
                    # start with forward motion
                    base_speed = math.min(MAX_SPEED, Kp_dist * goal_distance)

                    # adjust motion to account for heading error
                    goal_heading = get_goal_heading()
                    yaw_error    = (goal_heading - pose.orientation.yaw + math.pi) % (2 * math.pi) - math.pi
                    w            = Kp_heading * yaw_error

                    # drive
                    set_wheels(base_speed - w, base_speed + w)
                }
            }
        }
    }
}